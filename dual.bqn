# Generalized dual numbers are the field R extended with n distinct new elements Îµ_0, Îµ_1, ..., such that Îµ_i * Îµ_j = 0
# using MAGIC one can derive that f(x + a Îµ_0, y + b Îµ_1, ...) = f(x, y, ...) + a Îµ_0 f_0(x, y, ...) + b Îµ_1 f_1(x, y, ...) where f_n is the derivatie of f with respect to the nth argument
# thus it can be used for FULLY AUTOMATIC DIFFERENTIATION (real)

# Functions pre- or suffixed by C expets a real number as argument, as opposed to a Dual number.
Dual â‡ {n F eps:
    epsâ€¿n â‡
    # displays the number in form n + a Îµ_0 + b Îµ_1 + ...
    Disp â‡ {ğ•¤
        coeffs â† âˆ¾ (epsâ‰ 0) / (" + "âŠ¸âˆ¾)Â¨ (â€¢ReprÂ¨ eps) âˆ¾Â¨ ("Îµ_"âŠ¸âˆ¾)Â¨ â€¢ReprÂ¨ â†•â‰ eps
        (â€¢Repr n) âˆ¾ coeffs
    }

    # does ğ•© have the same dimensions as this?
    DimCheck â† {
    ğ•Š n : 6 = â€¢Type ğ•©?
        "must be equal in dimension" ! ğ•©.eps (=â—‹â‰ ) eps
        ğ•©
    ;
        ğ•© Dual 0Â¨eps
    }
    C â‡ { ğ•© Dual 0Ã—eps }

    Add â‡ {
        ğ•© â†© DimCheck ğ•©
        (n+ğ•©.n) Dual (eps+ğ•©.eps)
    }

    Sub â‡ {
        ğ•© â†© DimCheck ğ•©
        (n-ğ•©.n) Dual (eps-ğ•©.eps)
    }

    Mul â‡ {
        ğ•© â†© DimCheck ğ•©
        (nÃ—ğ•©.n) Dual (nÃ—ğ•©.eps) + (ğ•©.nÃ—eps)
    }

    PowC â‡ {
    F 0:
        C 1 # special case for xâ‹†0
    ;
        (nâ‹†ğ•©) Dual eps Ã— ğ•©Ã—nâ‹†ğ•©-1
    }

    EExp â‡ {F:
        expn â† â‹†n
        expn Dual eps Ã— expn
    }


    CExp â‡ {F:
        (ğ•©â‹†n) Dual eps Ã— (â‹†â¼ğ•©)Ã—ğ•©â‹†n
    }

    Sin â‡ {F:
        (â€¢math.Sin n) Dual eps Ã— â€¢math.Cos n
    }

    Cos â‡ {F:
        (â€¢math.Cos n) Dual -eps Ã— â€¢math.Sin n
    }
}
